# 二叉树

> 递归思想
- 清楚的知道当前函数有什么作用
- 在能够完成下一级的任务下，怎么完成当前任务
- 递归的边界是什么，什么时候能跳出


## 二叉树对应的JS对象结构
```javascript
const node = {
    value: undefined,
    left: null,
    right: null
}
```

## 一颗树
由node节点分叉简历，一个节点可以有两个节点，每个子节点又可以有两个节点，一直下去就像一棵树一样

## 遍历方法
- 先序遍历 根=>左=>右
- 中序遍历 左=>根=>右
- 后序遍历 左=>右=>根

## 先序遍历
**思路**
- 先序遍历先访问根节点
- 知道怎么访问左子节点，知道怎么访问右子节点
- 当前节点为空树时，跳出
```javascript
function orderTree(tree) {
    if(!tree) return
    visit(tree.value)
    orderTree(tree.left)
    orderTree(tree.right)
}
```

## 树的高度
**思路**
- 知道左子树的高度，知道右子树的高度
- 那么当前节点的高度 = max(右子树的高度, 左子树的高度) + 1
- 当树为空树，返回高度为0，跳出

```javascript
function getTreeHeight(tree) {
    if(!tree) return 0
    return Math.max(getTreeHeight(tree.left), getTreeHeight(tree.right)) + 1
}
```


## 交换子树
**思路**
- 左子树已经交换成功，右子树已经交换成功
- 将当前根节点的左右引用交换
- 如果当前树为空树，跳出
```javascript
function exChangeTree(tree) {
    if(!tree) return 0
    exChangeTree(tree.left)
    exChangeTree(tree.right)
    let temp = tree.left
    tree.left = tree.right
    tree.right = temp
    temp = null
}
```

## 节点个数
- 知道左子树节点个数，知道右节点个数
- 左子树节点  + 右子树节点 + 1
- 当前树为空树，返回0个，跳出
```javascript
function getTreeNodeCount(tree) {
    if(!tree) return 0
    return getTreeNodeCount(tree.left) + getTreeNodeCount(tree.right) + 1
}
```
## 对比两树
> diff算法的雏形
- 对比左树是否相等，对比右树是否相等
- 当前节点是否相等
- 如果有任意一节点为空树，另一节点存在，返回false，两空返回true
```javascript
function isSameTree(oneTree, TwoTree) {
    if(!oneTree && !TwoTree) return true
    else if(oneTree && TwoTree) {
        if(oneTree.val !== TwoTree.val) return false
        return isSameTree(oneTree.left, TwoTree.left) && isSameTree(oneTree.right, TwoTree.right)
    }else {
       return false
    }
}
```