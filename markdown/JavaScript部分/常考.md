## 1.怎么判断变量类型是否为引用类型
- 使用typeof
```javascript
variate !== null && (typeof variate === 'object' || typeof variate === 'function' )
```

- instanceof
```javascript
variate instanceof Object
```

- toString方法
```javascript
Object.prototype.toString.call(variate).slice(8, -1)
//原始类型也会调用对应的方法，因此这个方法其实不能判断到底是否为对象
```

## 2.检查是否是数组
- toString
- instanceof （注意它不可信，可能原型可能被修改setPropertyOf，__proto__属性）
- map、 slice等数组方法进行能力检测
- Array.isArray（不是ES6的，是ES5.x的）


## 3.typeof null === 'object'
null不是对象类型
- 在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 
- 虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

## 4.== 与 === 的区别
#### ==： 类型转换
- Object 转换成元素类型[Symbol.toPrimitive]，toString和valueOf函数
- undefined和null的祖传关系（null、undefined和其它任何数据类型都不相等），但是
```javascript
Number(undefined) = NaN
Number(null) = 0
```

- String和Boolean比较尽量转换为Number

#### ===：类型判定
先判断类型，再判断值


## 5.深拷贝和浅拷贝
#### 浅拷贝：
拷贝所有属性到新的对象，如果是对象那么拷贝的是地址，比如
- Object.assign
- 展开运算符...

#### 深拷贝：
深拷贝遇到对象的属性值如果还是一个对象那么会重新创建一个全新的对象，对象的属性名相同，属性值是再一次的“深拷贝”。常见的就是
- JSON.parse(JSON.stringify())，不过不能完全解决
    - 无法对undefined和Symbol类型处理
    - 无法处理序列化函数
    - 无法解决循环引用的问题

- 手动实现，loadsh插件

## 6.this值的指向
> 注意this在匿名函数和普通函数没用什么区别
- 全局环境的this => window，非箭头函数的普通函数调用 this => window
- 箭头函数，是在定义的函数的环境上下文的this值（注意，上层的this值也是变动的，只有当指向上层函数时确定this的值，才能确定箭头函数的this值）
- 函数被作为对象属性调用，this => 该对象
- Call、Apply、Bind 函数
- 作为构造函数内的this，被new，thi指向内部创建的对象

## 7.箭头函数
- 箭头函数体中的 this 对象，是定义函数时的全局上下文指向的对象，而不是使用函数时的对象
- 没有 this、super、arguments 和 new.target 绑定（不能new）
- 在class关键字里，绑定的箭头函数是在实例对象上的，而不是原型上的
- 无法改变this的值，call，bind，apply无效

## 8.闭包
#### 形成闭包的条件：
- 函数A内能够定义函数B
- 函数B 能访问函数A的变量
- 函数调用

#### 闭包的三个特性：
- JS在函数内部运行定义新的函数
- 在函数内部可以访问父亲函数的变量
- 函数作用第一公民，可以作为返回值（也可以直接向外暴露）

闭包的使用场景：
- 模块化，解决的问题有私有变量的隐藏，可以避免污染全局变量
- 柯里化、节流和防抖
- 一些回调函数、ajax、定时器、事件绑定方法

闭包的几个问题：
- 代码难以维护，函数可以一层嵌套一层，内函数可以访问祖先函数的变量
- 内存泄漏，需要及时的去清理，一些变量一直和闭包共存亡，占用内存空间


## 9.arguments
arguments 是一个对应于传递给函数的参数的类数组对象
几个属性：
- callee JS当前执行到该段代码时，正在执行的函数，匿名函数自调用
- length 函数的参数的长度
- 生成迭代对象属性，Symbol.iterator

## 10.内存泄漏并且如何解决
#### 垃圾回收机制：
找出那些不再使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码 执行中预定的收集时间），周期性的执行这一操作

#### 有几种方法：
- 标记清除。当变量进入环境（例如，在函数中声明一个变量）时，将这个变量标记为 “进入环境” 。从逻辑上讲， 永远不能释放进入环境的变量所占用的内存，因为我们在这个环境中可能随时会用到它们。当变量离开 环境时，则将其标记为 “离开环境"

- 引用计数。跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次 数就是 1。如果同一个值又被赋值给另一个变量，则引用次数加 1。相反，如果包含对这个值的引用的 变量有取了另一个值，则引用次数减 1。当这个值的引用次数变为 0 时，说明已经没法再访问这个值 了，因此可以将其占用的内存回收了。引用计数策略有一个很严重的问题：循环引用。所以不常用。 如果对象 A 中包含一个指针指向对象 B，而对象 B 中也包含一个指针指向对象 A。那么这两个对象引用 次数都是 2，但实际上已经可以回收了。若这种函数被反复多次调用，会导致大量内存得不到回收


## 11.原型和原型链
#### 原型：
是一个对象，我们可以通过new原型对应的构造函数来创建实例对象，当我们访问该实例对象的方法和属性时，先从该对象上查找，如果找不到，就会往它的原型上查找

#### 原型链：
由于对象的原型也可能是另外一个原型对象的构造函数的实例，那么如果访问对象的属性和方法在原型上也找不到，就会继续的往原型的原型上查找，如此递归下去，最终找到Object.prototype，并且它的原型为null，这样的一条由对象原型组成的节点就像链表一样，称为原型链


## 12.执行上下文
分为全局环境执行上下文，和函数环境执行上下文
做了什么？
- 组合实参和新参，形成arguments
- 函数声明提前，变量声明提前（多次声明忽略）
- 确定当前上下文的变量对象
- 确定this值
- 将当前变量对象加入到作用域链的最前端

当前真正处于的执行上下文的变量对象叫做活动对象


## 13.继承
#### 组合继承：
核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子 类的原型为 new Parent() 来继承父类的函数；缺点是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费

#### 寄生组合继承：
相较于组合继承，在进行设置Child.prototype时，不通过new Parent进行设置，而是Object.creat(Parent.prototype, { constructor: { value: Child, enumerable: false }}

#### Class 继承：
class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super ，因为这段代码可以看成 Parent.call(this, value)


## 15.什么是回流和重绘
- 回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建

- 重绘：当render tree中的一部分(或全部)因为元素的外观风格改变而需要重新构建
	
## 16.load、DOMContentLoaded、onreadystatechange区别：
Window.load事件等待文档的所有资源（样式、图片、视频、脚本）都加载完成才触发；Document.DOMContentLoaded 文档的DOM树构建完成的时候触发；Document.onreadystatechange是DOM构建之后，资源Load之前触发


	
## 17.script的async和defer的区别：

#### 共同点：
- Aysnc和Defer都可以异步的下载JS文件，不阻塞DOM的构建

#### 区别：
- Async 一旦脚本下载完成之后立即执行，这也说明了Async脚本执行是无序的
- Defer 有延迟执行的效果，等到DOM构建完成但DOMContentLoaded事件之前执行脚本，它的执行是有序的


## 18.Date数据类型

### 构造函数
```javascript
new Date()
// 时间戳
// DateString Date.parse()能够解析的
```
- 获取时间具体值：get + [英文单词]，比如getFullYear、 getMonth、getDate、getDay、getHours、getMinutes、getSeconds（时、分、秒记得+s）
- 注意getDay获取星期几（美国的第一天是星期日）

## 19.RegExp正则表达式

### 常用的符号
- ^，$ 以什么开头，以什么结尾
- \* => {0, n}，+ => {1, n}，? => {0, 1} 表示最少firstNumber次数，最多secondNumber
- . 点匹配的是非换行外的所有单个字符
- \d、\D数字和非数字；\s、\S空白字符和非空白字符
- \w、\W单个字符（数字，字母）

### 注意事项
- 正则注意转义字符，一些特殊的符号需要进行转义
- new RegExp() 字符串，字符串自带一层转义，如果在正则里还需要一层的话，需要多加一层转义

### 调用一些方法
- replace 替换匹配字符，返回新的字符串
```javascript
str.replace(regexp, replaceStr)//直接替换字符串
str.replace(regexp, function(matchStr, bracket1, bracket2, ....bracketn) {
    return replaceStr
})//回调函数返回值进行替换
```
- match 匹配字符，返回结果数组，未成功返回null
```javascript
str.mathc(regexp) //如果没有全局g，第一个元素为匹配字符，以后的元素是括号匹配成功
```

## 20.parseInt
parseInt(string, radix)   解析一个字符串并返回指定基数的十进制整数， 
- radix 是2-36之间的整数，表示被解析字符串的基数，如果radix不是这两数之间，返回的都是NaN，如果无法解析返回的也是NaN