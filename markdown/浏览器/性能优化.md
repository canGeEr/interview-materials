# 前端性能优化

## 1.网络篇
根据从URL到页面渲染，处于网络有DNS解析TCP三次握手，因此对于的优化规则

- 减少请求的次数（对于JS和CSS文件尽量的去合并）
- 减少单次请求的时间（减小单个文件的体积）

#### 请求次数减少
- webpack做按需加载、和合并资源
- CSS Sprites 雪碧图、Base64图片

#### 减少单次请求的文件大小
- GZIP 压缩
- 图片选择合适的格式


## 2.存储篇

### HTTP 缓存机制探秘
> HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存

#### 强缓存：
根据字段判断是否从缓存中获取数据还是再次发送请求，返回的**状态码+（从哪个缓存获取的）**     

**两个属性：**
- Expires：http1.0 （本地时间比较过期时间，依赖本地时间）
- cache-control：http1.1 优先级更高 （时间戳，相对准确）

**cache-control 分析：**
> 缓存可以是在浏览器中private（默认），也可以在中间的代理服务器中public（CDN）
- max-age  设置浏览器缓存的的过期时间
- s-maxage 设置public的过期时间
- no-cache 之间绕过浏览器的缓存，去请求服务器（中间可能有代理服务器缓存）
- no-store 之间不请求缓存，完全重新的请求文档

#### 协商缓存：
浏览器与服务器合作之下的缓存策略。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），**资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304**

**两种实现：**
- last-modified 浏览器收到响应信息的last-modified时间戳，再次请求时将其作为if-modified-since，服务器判断和最好一个修改时间是否一致，如果更改返回新的last-modified，否则**返回304**，且不再有last-modified
    
- Etag 是由服务器为每个资源生成的唯一的标识字符串，和上面类似，先响应报文收到eTag，请求报文发送if-None-Match

**两者比较：**
- Etag优先级比last-modified高
- last-modified以秒计数是否更新，不够精确，Etag更加精准
- last-modified开销小

### 浏览器的本地存储机制
**cookie，localStorage，sessionStorage，indexDB 四种：**
- Cookie 一般由服务器设置决定事件长短，4K，每次请求带上cookie
- localStorage 需要手动清除时间不限，5M
- sessionStorage 关闭网页就清除，5M
- indexDB 需要手动清除时间不限，大小不限，提供查找接口，还能建立索引

它们都有同源策略限制

**localStorage和sessionStorage的区别：**        
出于性能考虑，如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储
	
**Cookie如何设置：**        
Cookie直接设置name和value，如name=value，如果还需要设置其它属性，那么加上“;”号，设置expires=过期时间
