## 1.跨域
> 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败

> 浏览器限制**XMLHttpRequest**、**fetch**在非同源的情况下，而img、script或者link等等默认都不会有跨域限制

### 为什么需要跨域限制
- 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求
- 第三方访问该网站数据，可以盗用用户身份信息，用户隐私数据

### 同源和站点
- 同源：协议、域名或者端口        
- 同站点：域名相同        

### 浏览器怎么去判断是否跨域
> 简单请求和非简单请求，核心点就是请求“大”考虑发出是不是无效浪费
- 服务器再请求投写入origin字段为当前域名
- 简单请求浏览器先发出，再判断是否跨域
- 复杂请求，先发出预检请求，判断是否允许跨域，再判断是否发出

**如何区别复杂和简单请求**
- 请求方法是HEAD，GET，POST之一
- HTTP的头信息不超出以下几种字段（没有自定义的头部）：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

**复杂请求怎么做的：**      
option预检请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错（是否允许跨域）


### 解决跨域

- JSONP 就是利用 script 标签没有跨域限制的漏洞。通过 script 标签指向一个需要访问的地址并，服务器返回JS代码，浏览器解析执行JS代码，触发前端注册的回调函数，并传入参数
    - 兼容性好，但是只用于get请求
    - 本质是后端返回的脚本调用jsonp注册的回调函数，参数为JSON字符串

- CORS 后端实现，后端设置Access-Control-Allow-Origin 开启跨域模式
    - Access-Control-Allow-Origin设置通配符允许所有站点访问，但是和Access-Control-Allow-Credentials是否允许携带cookie为true冲突，
    - 前端要携带cookie的话前端的withCredentials设置true，后端...Allow-Origin不能设置通配符，必须指定域名，并且...Allow-Credentials设置为true
    - 但是这样的话有个问题就是，后端只能预先的指定跨域的域名。因此你肯定想到，我们就动态的允许跨域字段（前面说了，前端请求跨域自动带上origin字段，那么后端每次判断的时候，自动设置该值写入...Allow-Origin）
- document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域
- postMessage 和 iframe 跨域
- nginx 反向代理

## 2.Cookie 和 Seeion 区别
### Cookie：
- 存储于客户端电脑上的文本文件中，只要客户端cookie开放且有数据，每一次请求都会自动 添加到http报文中，后台可以实时接收观察获取这些Cookie
- 属性有：name=value，domain、path、maxAge、expires、secure、httpOnly
- HTTP 是无状态的协议
- Cookie 是不可跨域的

### Session：
- 基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中（当然也不是必须存储在cookie中）
- 客户端第一次访问，服务端记录，并生成唯一的标识sessionId，写回给浏览器；浏览器收到信息后，存储在对应的域下；当浏览器再次发送的时候自动判断是否在该域下携带cookie，并以cookie的sessionId识别身份信息

### 区别：
- Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的
- Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型
- Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效
- 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源


## 3.原生的ajax
- 生成XMLHttpRequest对象
- 绑定响应函数onreadystatechange
- 调用open方法，设置对应的请求方式，请求路径，是否异步
- 使用实例的setRequestHeader方法设置一些请求头的信息
- 调用send方法，如果包含请求体，请求体数据传入，真正发出请求

## 4.axios
- Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库
- 浏览器端/node 端都可以使用，浏览器中创建XMLHttpRequests，在node环境使用http对象发送ajax请求
- 支持请求／响应拦截器、支持请求取消
- 安全性更高，客户端支持防御 XSRF