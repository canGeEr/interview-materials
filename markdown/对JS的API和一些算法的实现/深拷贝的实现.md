## 深拷贝
> 没有对Date数据类型，正则类型进行处理

> 解决了循环引用，和Symbol问题，undefined问题

```javascript
// W3C的实现https://www.w3cschool.cn/article/8b3a1e469cd340.html
const deepClone = (function() {
    const hasCloneArr = new Map()
    function _deepClone(variate) {
        let target = null
        if(!isObject(variate)) return variate
        if(hasCloneArr.has(variate)){
            return hasCloneArr.get(variate)
        }
        target = isArray(variate) ? new Array() : Object.create(variate.__proto__)
        hasCloneArr.set(variate, target) //存储进去
        //遍历对象自有属性包括Symbol
        Reflect.ownKeys(variate).forEach(key => {
            target[key] = _deepClone(variate[key])
        });
        return target
    }

    return function(variate, isDeep) {
        if(!isDeep) return Object.assign({}, variate)
        try {//这个会忽略undefined，Symbol，函数，无法解决循环引用
            return JSON.parse(JSON.stringify(variate))
        }catch {
            return _deepClone(variate)
        }
    }

    function isObject(variate) {
        //1. instanceof Object.prototype.toString.call
       return variate !== null && (typeof variate === 'object' || typeof variate === 'function')
    }
    
    function isArray(variate) {
        if(Array.isArray) {
            return Array.isArray(variate)
        }
        return Object.prototype.toString(variate).slice(8, -1) === 'Array'
    }
})()
```