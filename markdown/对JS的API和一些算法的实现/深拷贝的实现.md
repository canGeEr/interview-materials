## 深拷贝
深拷贝的就是在拷贝的时候，需要将当前要拷贝的对象内的所有引用类型的属性进行完整的拷贝，也就是说拷贝出来的对象和原对象之间没有任何数据是共享的，所有的东西都是自己独占的一份

> 没有对Date数据类型，正则类型进行处理 [具体的数据类型处理](https://www.w3cschool.cn/article/8b3a1e469cd340.html)
```javascript
// W3C的实现
const deepClone = (function() {
  let objMap = new Map() // 也可以是二维数组

  function __deepClone(variate) {
    if(!isObject(variate)) return variate
    const circulateObj = objMap.get(variate)
    if(circulateObj) return circulateObj
    const PrototypeClass = Reflect.getPrototypeOf(variate).constructor
    const newObj = new PrototypeClass()
    objMap.set(variate, newObj)
    Reflect.ownKeys(variate).forEach((prototype)=>{
      debugger
      newObj[prototype] = __deepClone(variate[prototype])
    })
    return newObj
  }
  
  // 如何判断一个对象是否是变量
  function isObject(variate) {
    return variate !== null && (typeof variate === 'object' || typeof variate === 'function')
  }
  
  function isArray(variate) {
    if(Array.isArray) {
      return Array.isArray(variate)
    }
    return Object.prototype.toString.call(variate).slice(8, -1)  === 'array'
  }

  return function exposeFun(variate, {isDeep, canJson}) {
    if(!isDeep) return Object.assign({}, variate)
    try {
      if(canJson) return JSON.parse(JSON.stringify(variate))
    } catch(e) {
      console.warn(e, '该对象无法json化，使用深拷贝兜底')
    }
    objMap = new Map()
    return __deepClone(variate)
  }
})();
```

## 判断两个对象是否相互引用
```javascript
const canVisited = function(variate, otherVariate) {
  let objMap = null
  
  function __canVisited(variate, otherVariate) {
    if(!isObject(variate)) return false
    if(objMap.has(variate)) return false
    if(variate === otherVariate) return true
    objMap.set(variate, true)
    const flag = Reflect.ownKeys(variate).some((prototype)=>{
      const flag = __canVisited(variate[prototype], otherVariate)
      return flag
    })
    return flag
  }

  function isObject(variate) {
    return variate !== null && (typeof variate === 'object' || typeof variate === 'function')
  }

  return function exposeFun(variate, otherVariate) {
    objMap = new Map()
    return __canVisited(variate, otherVariate)
  }
}

const isLoopUsed = function(first, second) {
  const result1 = canVisited(first, second) 
  const result2 = canVisited(second, first)
  return result1 && result2
}

const node1 = {
  name: 'node1',
  next: null
}

const node2 = {
  name: 'node2',
  next: null
}

const node3 = {
  name: 'node3',
  next: null
}

node1.next = node2
node2.next = node3
node3.next = node1

console.log(isLoopUsed(node1, node2), isLoopUsed(node1, node3), isLoopUsed(node3, node2))
```