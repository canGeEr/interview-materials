## 1.怎么判断变量类型是否为引用类型

- 使用 typeof

```javascript
variate !== null &&
  (typeof variate === "object" || typeof variate === "function");
```

- instanceof

```javascript
variate instanceof Object;
```

- toString 方法

```javascript
Object.prototype.toString.call(variate).slice(8, -1);
//原始类型也会调用对应的包装对象的方法，因此这个方法其实不能判断到底是否为对象
```

Object.prototype.toString 更多的应该扮演 classOf 的角色

## 2.检查是否是数组

- toString
- instanceof （注意它不可信，可能原型可能被修改 setPropertyOf，**proto**属性, Symbol.hasInstanceof）
- map、 slice 等数组方法进行能力检测
- Array.isArray（不是 ES6 的，是 ES5.x 的）

## 3.typeof null === 'object'

null 不是对象类型

- 在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object
- 虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

## 4.== 与 === 的区别

#### ==： 类型转换

- Object 转换成元素类型[Symbol.toPrimitive]，toString 和 valueOf 函数
- undefined 和 null 的祖传关系（null、undefined 和其它任何数据类型都不相等），但是

```javascript
Number(undefined) = NaN
Number(null) = 0
```

- String 和 Boolean 比较尽量转换为 Number

#### ===：类型判定

先判断类型，再判断值

## 5.深拷贝和浅拷贝

拷贝出来的对象和原对象之间没有任何数据是共享的，所有的东西都是自己独占的一份

### 浅拷贝：

拷贝所有属性到新的对象，如果是对象那么拷贝的是地址，比如

- Object.assign
- 展开运算符...

### 深拷贝：

深拷贝遇到对象的属性值如果还是一个对象那么会重新创建一个全新的对象，对象的属性名相同，属性值是再一次的“深拷贝”。常见的就是

- JSON.parse(JSON.stringify())，不过不能完全解决

  - 无法对 undefined 和 Symbol 类型处理
  - 无法处理序列化函数，怎么拷贝函数
  - 无法解决循环引用的问题

- 手动实现，loadsh 插件

## 6.this 值的指向

> 注意 this 在匿名函数和普通函数没用什么区别

- 全局 this => window
- 函数
  - 普通函数
    - 普通函数调用 this => window
    - 函数被作为对象属性调用，this => 该对象
    - Call、Apply、Bind 函数
    - 作为构造函数被 new，this 指向内部创建的对象
  - 箭头函数
    - 箭头函数体中的 this 对象，是定义函数时的全局上下文指向的对象，而不是使用函数时的对象（解释不清除，let that = this 的语法糖）
    - 没有 this、super、不能 new
    - 没有 arguments
    - 在 class 关键字里，为 class 属性成员绑定的箭头函数是在实例对象上的，而不是原型上的
    - 无法改变 this 的值，call，bind，apply 无效

## 8.闭包

### 形成闭包的条件：

- 函数 A 内能够定义函数 B
- 函数 B 能访问函数 A 的变量
- 函数调用

### 闭包的三个特性：

- JS 在函数内部运行定义新的函数
- 在函数内部可以访问父亲函数的变量
- 函数作用第一公民，可以作为返回值（也可以直接向外暴露）

### 闭包

函数内部可以定义子函数，子函数可以被暴露到父函数之外使用，子函数在声明的时候进行一遍扫描，将内部的访问父函数的变量，复制打包 closure，绑定在自身上，因此当父函数执行结束退出的时候，即使栈空，子函数依然能够正确的访问“父函数的变量”

### 闭包的使用场景：

- 模块化，解决的问题有私有变量的隐藏，可以避免污染全局变量
- 柯里化、节流和防抖
- 一些回调函数、ajax、定时器、事件绑定方法

闭包的几个问题：

- 代码难以维护，函数可以一层嵌套一层，内函数可以访问祖先函数的变量
- 内存泄漏，需要及时的去清理，一些变量一直和闭包共存亡，占用内存空间

## 9.arguments

arguments 是一个对应于传递给函数的参数的类数组对象
几个属性：

- callee JS 当前执行到该段代码时，正在执行的函数，匿名函数自调用
- length 函数的参数的长度
- 生成迭代对象属性，Symbol.iterator

## 11.原型和原型链

#### 原型：

是一个对象，我们可以通过 new 原型对应的构造函数来创建实例对象，当我们访问该实例对象的方法和属性时，先从该对象上查找，如果找不到，就会往它的原型上查找

#### 原型链：

由于对象的原型也可能是另外一个原型对象的构造函数的实例，那么如果访问对象的属性和方法在原型上也找不到，就会继续的往原型的原型上查找，如此递归下去，最终找到 Object.prototype，并且它的原型为 null，这样的一条由对象原型组成的节点就像链表一样，称为原型链

## 12.执行上下文

分为全局环境执行上下文，和函数环境执行上下文
做了什么？

- 组合实参和形参，形成 arguments
- 函数声明提前，变量声明提前（多次声明忽略）
- 确定当前上下文的变量对象
- 确定 this 值
- 将当前变量对象加入到作用域链的最前端

当前真正处于的执行上下文的变量对象叫做活动对象

## 13.继承

### 组合继承：

核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子 类的原型为 new Parent() 来继承父类的函数；缺点是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了一份父类属性，存在内存上的浪费

### 寄生组合继承：

相较于组合继承，在进行设置 Child.prototype 时，不通过 new Parent 进行设置，而是 Object.create(Parent.prototype, { constructor: { value: Child, enumerable: false }}

#### Class 继承：

class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super ，因为这段代码可以看成 Parent.call(this, value)

Class 写法就是语法糖，你可以把 Class 的大括号直接想象成函数执行，只不过先执行 constructor 函数再执行外面的

## 15.什么是回流和重绘

- 回流：当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建 layout

- 重绘：当 render tree 中的一部分(或全部)因为元素的外观风格改变而需要重新绘制 paint

## 16.load、DOMContentLoaded、onreadystatechange 区别：

- Document.DOMContentLoaded 文档的 DOM 树构建完成的时候触发
- - Document.onreadystatechange 是 DOM 构建之后，资源 Load 之前触发
- Window.load 事件等待文档的所有资源（样式、图片、视频、脚本）都加载完成才触发

## 17.script 的 async 和 defer 的区别：

- Aysnc 和 Defer 都可以异步的下载 JS 文件，不阻塞 DOM 的构建

- Async 一旦脚本下载完成之后立即执行，这也说明了 Async 脚本执行是无序的
- Defer 有延迟执行的效果，等到 DOM 构建完成但 DOMContentLoaded 事件之前执行脚本，它的执行是有序的

## 18.Date 数据类型

[JS 的 Date 类](https://gitee.com/cangeer/learning/blob/master/JAVASCRIPT/ES6%E4%B9%8B%E5%89%8D/08-Date%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B.md)

### 构造函数

```javascript
new Date();
// 时间戳
// DateString Date.parse()能够解析的
```

- 获取时间具体值：get + [英文单词]，比如 getFullYear、 getMonth、getDate、getDay、getHours、getMinutes、getSeconds（时、分、秒记得+s）
- 注意 getDay 获取星期几（美国的第一天是星期日）

## 19.RegExp 正则表达式

[JS 的 RegExp](https://gitee.com/cangeer/learning/blob/master/JAVASCRIPT/ES6%E4%B9%8B%E5%89%8D/09-RegExp%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%B1%BB%E5%9E%8B.md)

### 常用的符号

- ^，$ 以什么开头，以什么结尾
- \* => {0, n}，+ => {1, n}，? => {0, 1} 表示最少 firstNumber 次数，最多 secondNumber
- . 点匹配的是非换行外的所有单个字符
- \d、\D 数字和非数字；\s、\S 空白字符和非空白字符
- \w、\W 单个字符（数字，字母）

### 注意事项

- 正则注意转义字符，一些特殊的符号需要进行转义
- new RegExp() 字符串，字符串自带一层转义，如果在正则里还需要一层的话，需要多加一层转义

### 调用一些方法

- replace 替换匹配字符，返回新的字符串

```javascript
str.replace(regexp, replaceStr)//直接替换字符串
str.replace(regexp, function(matchStr, bracket1, bracket2, ....bracketn) {
    return replaceStr
})//回调函数返回值进行替换
```

- match 匹配字符，返回结果数组，未成功返回 null

```javascript
str.mathc(regexp); //如果没有全局g，第一个元素为匹配字符，以后的元素是括号匹配成功
```

## 20.进制转换

默认是 10 进制转换，因此没有感知

- parseInt(variate, radix) 以 radix 为基数，解析一个字符串并返回等大的十进制整数， radix 是 2-36 之间的整数，表示被解析字符串的基数
  - 36 >= radix >= 2 ，不然返回 NaN，如果是 0 特殊，返回本身
  - 第一个非空格字符不能转换为数字，不然返回 NaN
- toString(variate, radix) 将 variate 看出 10 进制的数，转换为 radix 为基数的数

他们的功能刚好相反：  
parseInt 识别 variate 以 radix 为基，转换为 10 进制  
toString 识别 variate 以 10 为基，转换为 radix 进制

```javascript
let variate = "34";
variate = parseInt(variate, 5);
variate = variate.toString(5);
//'34'
```

## 10.内存泄漏并且如何解决

#### 垃圾回收机制：

找出那些不再使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码 执行中预定的收集时间），周期性的执行这一操作

#### 有几种方法：

- 标记清除。当变量进入环境（例如，在函数中声明一个变量）时，将这个变量标记为 “进入环境” 。从逻辑上讲， 永远不能释放进入环境的变量所占用的内存，因为我们在这个环境中可能随时会用到它们。当变量离开 环境时，则将其标记为 “离开环境"

- 引用计数。跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次 数就是 1。如果同一个值又被赋值给另一个变量，则引用次数加 1。相反，如果包含对这个值的引用的 变量有取了另一个值，则引用次数减 1。当这个值的引用次数变为 0 时，说明已经没法再访问这个值 了，因此可以将其占用的内存回收了。引用计数策略有一个很严重的问题：循环引用。所以不常用。 如果对象 A 中包含一个指针指向对象 B，而对象 B 中也包含一个指针指向对象 A。那么这两个对象引用 次数都是 2，但实际上已经可以回收了。若这种函数被反复多次调用，会导致大量内存得不到回收

#### 新生代老生代

> V8 垃圾回收：
> V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分

**新生代算法**  
新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了

**老生代算法**  
老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

在讲算法前，先来说下什么情况下对象会出现在老生代空间中：

- 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
