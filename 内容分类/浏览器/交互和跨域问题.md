# 跨域
> 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败

同源：协议、域名或者端口        
同站点：域名相同        

为什么需要：
- 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求
- 第三方访问该网站数据，可以盗用用户身份信息


## 怎么去做跨域

- JSONP 就是利用 script 标签没有跨域限制的漏洞。通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时
    - 兼容性好，但是只用于get请求
    - 本质是后端返回的脚本调用jsonp注册的回调函数，参数为JSON字符串

- CORS 后端实现，后端设置Access-Control-Allow-Origin 开启跨域模式
    - Access-Control-Allow-Origin设置通配符允许所有站点访问，但是和Access-Control-Allow-Credentials是否允许携带cookie为true冲突，
    - 前端要携带cookie的话前端的withCredentials设置true，后端...Allow-Origin不能设置通配符，必须指定域名，并且...Allow-Credentials设置为true        

    **实现 => 简单请求和复杂请求：**
    区分请求类别：
    - 请求方法是HEAD，GET，POST之一
    - HTTP的头信息不超出以下几种字段（没有自定义的头部）：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

    复杂请求：option预检请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错（是否允许跨域）
- nginx 反向代理
- document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域
- postMessage 和 iframe 跨域


## Cookie 和 Seeion 区别
#### Cookie：
- 存储于客户端电脑上的文本文件中，只要客户端cookie开放且有数据，每一次请求都会自动识别当前请求的路径，将电脑存储对于域下的cookie 添加到http报文中，后台可以实时接收观察获取这些Cookie
- 属性有：name=value，domain、path、maxAge、expires、secure、httpOnly
    - 有效范围：domain、path
    - 有效时间：maxAge（相对时间）、expires（过期时间） ，maxAge的优先级更高，如果两者都没有的话，Chrome里过期时间会显示为Session或N/A
    - 安全：httpOnly、SameSite，属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问；“SameSite”可以防范“跨站请求伪造”（XSRF），设置成Strict可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送；还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在
- HTTP 是无状态的协议
- Cookie 是不可跨域的



#### Session：
- 基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中（当然也不是必须存储在cookie中）
- 客户端第一次访问，服务端记录，并生成唯一的标识sessionId，写回给浏览器；浏览器收到信息后，存储在对应的域下；当浏览器再次发送的时候自动判断是否在该域下携带cookie，并以cookie的sessionId识别身份信息

#### 区别：
- Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的
- Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型
- Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效
- 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源


## 原生的Ajax
- 生成XMLHttpRequest对象
- 绑定响应函数onreadystatechange
- 调用open方法，设置对应的请求方式，请求路径，是否异步
- 使用实例的setRequestHeader方法设置一些请求头的信息
- 调用send方法，如果包含请求体，请求体数据传入，真正发出请求
```javascript
const xhr = new XMLHttpRequest()
xhr.setRequestHeader(property, value)
xhr.onreadystatechange = function() {

}
xhr.open(method, url, async)
xhr.send(data) // 发送的数据就是请求的实体内容
```
另外的：
XMLHttpRequest实例上的三个属性：
- responseText 获得字符串形式的响应数据。
- responseXML 获得XML 形式的响应数据
- readyState 用来标识当前XMLHttpRequest实例对象处于什么状态。
readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义：
  - 0：未初始化 -- 尚未调用.open()方法；
  - 1：启动 -- 已经调用.open()方法，但尚未调用.send()方法；
  - 2：发送 -- 已经调用.send()方法，但尚未接收到响应；
  - 3：接收 -- 已经接收到部分响应数据；
  - 4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用

## axios
- Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库
- 浏览器端/node 端都可以使用，浏览器中创建XMLHttpRequests，在node环境使用http对象发送ajax请求
- 支持请求／响应拦截器、支持请求取消
- 安全性更高，客户端支持防御 XSRF