<div id="app"></div>

<script>
  function h(tag, props, children) {
    return {
      tag,
      props,
      children
    }
  }

  function mount(vnode, container) {
    const el = document.createElement(vnode.tag)
    // console.log(el);
    vnode.el = el
    // props
    if (vnode.props) {
      for (const key in vnode.props) {
        const value = vnode.props[key]
        if (key.startsWith('on')) {
          el.addEventListener(key.slice(2).toLowerCase(), value)
        } else {
          el.setAttribute(key, value)
        }
      }
    }
    // children
    if (vnode.children) {
      if (typeof vnode.children === 'string') {
        el.textContent = vnode.children
      } else {
        vnode.children.forEach(child => {
          mount(child, el)
        })
      }
    }
    container.appendChild(el)
  }

  function patch(n1, n2) {
    if (n1.tag === n2.tag) {
      //è¿™ä¸ªåˆ†æ”¯ä¸ºæ–°æ—§èŠ‚ç‚¹tagç±»å‹ç›¸åŒ
      //è¿™é‡Œéœ€è¦å°†çœŸå®domèŠ‚ç‚¹el,åœ¨æ¯æ¬¡patchæ—¶å‘åä¼ é€’,ä¿è¯æ¯æ¬¡æ›´æ–°çš„éƒ½æ˜¯
      //è¿™ä¸ªèŠ‚ç‚¹.
      const el = (n2.el = n1.el);
      //diff props
      const oldProps = n1.props || {};
      const newProps = n2.props || {};
      //æ·»åŠ æ–°çš„å±æ€§æˆ–æ›´æ”¹åŸæ¥å·²æœ‰ä½†å˜åŒ–äº†çš„å±æ€§
      for (let key in newProps) {
        const oldValue = oldProps[key];
        const newValue = newProps[key];
        if (newValue !== oldValue) {
          el.setAttribute(key, newValue);
        }
      }
      //ç§»é™¤æ–°å±æ€§ä¸­æ²¡æœ‰çš„å±æ€§
      for (let key in oldProps) {
        if (!(key in newProps)) {
          el.removeAttribute(key);
        }
      }
      //diff children
      const oldChildren = n1.children;
      const newChildren = n2.children;
      //åœ¨diff childrençš„æ—¶å€™,æœ‰å››ä¸ªä¸»è¦åˆ†æ”¯
      // 1.æ–°è€éƒ½æ˜¯string
      // 2.æ–°: array è€: string
      // 3.æ–°: string è€: array
      // 4.æ–°è€éƒ½æ˜¯array
      if (typeof newChildren === "string") {
        if (typeof oldChildren === "string") {
          //æƒ…å†µ1
          if (oldChildren !== newChildren) {
            el.innerHTML = newChildren;
          }
        } else {
          //æƒ…å†µ3
          el.innerHTML = newChildren;
        }
      } else if (typeof oldChildren === "string" && Array.isArray(newChildren)) {
        //æƒ…å†µ2
        el.innerHTML = "";
        newChildren.forEach((child) => mount(child, el));
      } else if (Array.isArray(oldChildren) && Array.isArray(newChildren)) {
        //æƒ…å†µ4 æ˜¯æœ€å¤æ‚çš„æƒ…å†µ
        //è¿™é‡Œç®€å•èµ·è§å¹¶æ²¡æœ‰çœŸæ­£å®ç°vueä¸­çš„diffç®—æ³•,è€Œæ˜¯é€‰å–äº†ä¸€ä¸ªä½æ•ˆä½†
        //å®¹æ˜“ç†è§£çš„ç®—æ³•,ä½†å…¶å®vueä¸­å¦‚æœä¸ç»™å…ƒç´ æä¾›keyçš„è¯,ä¹Ÿä¼šä½¿ç”¨è¿™ä¸ª
        //ç®—æ³•,è¿™ä¸ªç®—æ³•åœ¨å­å…ƒç´ çš„tagä¸ä¼šå˜çš„æƒ…å†µä¸‹éå¸¸é«˜æ•ˆ,ä½†å¦‚æœtagä¼šå˜
        //åˆ™ä¼šå› ä¸ºä¸å¿…è¦çš„åˆ›é€ å’Œåˆ é™¤èŠ‚ç‚¹,è€Œå˜å¾—ä¸é‚£ä¹ˆé«˜æ•ˆ.
        const minLength = Math.min(oldChildren.length, newChildren.length);
        for (let i = 0; i < minLength; i++) {
          patch(oldChildren[i], newChildren[i]);
        }
        //è€çš„childrené•¿åº¦è¾ƒå°,åˆ™è¯´æ˜è¦æ·»åŠ èŠ‚ç‚¹
        if (oldChildren.length === minLength) {
          for (let i = minLength; i < newChildren.length; i++) {
            mount(newChildren[i], el);
          }
        } else {
          //åä¹‹,åˆ™è¯´æ˜è¦åˆ é™¤èŠ‚ç‚¹
          for (let i = minLength; i < oldChildren.length; i++) {
            el.removeChild(oldChildren[i].el);
          }
        }
      }
    } else {
      //æ ‡ç­¾ç±»å‹ä¸åŒæ—¶éœ€è¦ç”¨æ–°èŠ‚ç‚¹æ›¿æ¢èŠ‚ç‚¹
      //è¿™é‡Œå¹¶æ²¡æœ‰å®ç°ğŸ˜‚
      //å›å¤´å†è¡¥
    }
  }

  let activeEffect

  class Dep {
    // è®¢é˜…è€…æ¨¡å¼
    subscribers = new Set()
    // å‘ç”Ÿå˜åŒ–
    depend() {
      if (activeEffect) {
        this.subscribers.add(activeEffect)
      }
    }
    // é€šçŸ¥æ›´æ–°
    notify() {
      this.subscribers.forEach(effect => {
        effect()
      })
    }
  }

  function watchEffect(effect) {
    activeEffect = effect;
    effect()
    activeEffect = null
  }
  
  const targetMap = new WeakMap()

  function getDep(target, key) {
    let depsMap = targetMap.get(target)
    if (!depsMap) {
      depsMap = new Map()
      targetMap.set(target, depsMap)
    }
    let dep = depsMap.get(key)
    if (!dep) {
      dep = new Dep()
      depsMap.set(key, dep)
    }
    return dep
  }

  const reactiveHandles = {
    get(target, key, receiver) {
      const dep = getDep(target, key)
      dep.depend()
      return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
      const dep = getDep(target, key)
      const result = Reflect.set(target, key, value, receiver)
      dep.notify()
      return result
    }
  }

  function reactive(raw) {
    return new Proxy(raw, reactiveHandles)
  }

  const App = {
    data: reactive({
      count: 0
    }),
    render () {
      return h('div', {
        onClick: () => {
          this.data.count++
        },
      }, String(this.data.count))
    }
  }

  function mountApp(component, container) {
    let isMounted = false
    let prevVdom
    watchEffect(() => {
      if(!isMounted) {
        prevVdom = component.render()
        mount(prevVdom, container)
        isMounted = true
      } else {
        const newVdom = component.render()
        patch(prevVdom, newVdom)
        prevVdom = newVdom
      }
    })
  }

  mountApp(App, document.getElementById('app'))

</script>